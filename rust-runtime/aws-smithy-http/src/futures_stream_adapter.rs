// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

use crate::body::SdkBody;
use crate::byte_stream::error::Error as ByteStreamError;
use crate::byte_stream::ByteStream;
use bytes::Bytes;
use futures_core::stream::Stream;
use std::pin::Pin;
use std::task::{Context, Poll};

/// New-type wrapper to enable the impl of the `futures_core::stream::Stream` trait
///
/// [`ByteStream`] no longer implements `futures_core::stream::Stream` so we wrap it in the
/// new-type to enable the trait when it is required.
///
/// This is meant to be used by codegen code, and users should not need to use it directly.
pub struct FuturesStreamCompatByteStream(ByteStream);

impl FuturesStreamCompatByteStream {
    /// Creates a new `FuturesStreamCompatByteStream` by wrapping `stream`.
    pub fn new(stream: ByteStream) -> Self {
        Self(stream)
    }

    /// Returns [`SdkBody`] of the wrapped [`ByteStream`].
    pub fn into_inner(self) -> SdkBody {
        self.0.into_inner()
    }
}

impl Stream for FuturesStreamCompatByteStream {
    type Item = Result<Bytes, ByteStreamError>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        Pin::new(&mut self.0).poll_next(cx)
    }
}

#[cfg(feature = "event-stream")]
/// New-type wrapper to enable the impl of the `futures_core::stream::Stream` trait
///
/// [`crate::event_stream::MessageStreamAdapter`] no longer implements `futures_core::stream::Stream`
/// so we wrap it in the new-type to enable the trait when it is required.
///
/// This is meant to be used by codegen code, and users should not need to use it directly.
pub struct FuturesStreamCompatEventStream<T, E>(crate::event_stream::MessageStreamAdapter<T, E>);

#[cfg(feature = "event-stream")]
impl<T, E> FuturesStreamCompatEventStream<T, E> {
    /// Creates a new `FuturesStreamCompatEventStream` by wrapping `adapter`.
    pub fn new(adapter: crate::event_stream::MessageStreamAdapter<T, E>) -> Self {
        Self(adapter)
    }
}

#[cfg(feature = "event-stream")]
impl<T, E: std::error::Error + Send + Sync + 'static> Stream
    for FuturesStreamCompatEventStream<T, E>
{
    type Item = Result<Bytes, crate::result::SdkError<E>>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        Pin::new(&mut self.0).poll_next(cx)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use aws_smithy_async::future::fn_stream::FnStream;
    use aws_smithy_eventstream::error::Error;
    use aws_smithy_eventstream::frame::MarshallMessage;
    use aws_smithy_eventstream::frame::{Message, NoOpSigner};
    use futures_core::stream::Stream;

    #[derive(Debug, Eq, PartialEq)]
    struct TestMessage(String);

    #[derive(Debug)]
    struct Marshaller;
    impl MarshallMessage for Marshaller {
        type Input = TestMessage;

        fn marshall(&self, input: Self::Input) -> Result<Message, Error> {
            Ok(Message::new(input.0.as_bytes().to_vec()))
        }
    }
    #[derive(Debug)]
    struct ErrorMarshaller;
    impl MarshallMessage for ErrorMarshaller {
        type Input = TestServiceError;

        fn marshall(&self, _input: Self::Input) -> Result<Message, Error> {
            Err(Message::read_from(&b""[..]).expect_err("this should always fail"))
        }
    }

    #[derive(Debug)]
    struct TestServiceError;
    impl std::fmt::Display for TestServiceError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "TestServiceError")
        }
    }
    impl std::error::Error for TestServiceError {}

    fn check_compatible_with_hyper_wrap_stream<S, O, E>(stream: S) -> S
    where
        S: Stream<Item = Result<O, E>> + Send + 'static,
        O: Into<Bytes> + 'static,
        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>> + 'static,
    {
        stream
    }

    #[cfg(feature = "event-stream")]
    #[test]
    fn test_message_adapter_stream_can_be_made_compatible_with_hyper_wrap_stream() {
        let stream = FnStream::new(|tx| {
            Box::pin(async move {
                let message = Ok(TestMessage("test".into()));
                tx.send(message).await.expect("failed to send");
            })
        });
        check_compatible_with_hyper_wrap_stream(FuturesStreamCompatEventStream(
            crate::event_stream::MessageStreamAdapter::<TestMessage, TestServiceError>::new(
                Marshaller,
                ErrorMarshaller,
                NoOpSigner {},
                stream,
            ),
        ));
    }

    #[test]
    fn test_byte_stream_stream_can_be_made_compatible_with_hyper_wrap_stream() {
        let stream = ByteStream::from_static(b"Hello world");
        check_compatible_with_hyper_wrap_stream(FuturesStreamCompatByteStream::new(stream));
    }
}
