use std::error::Error;

/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
/// This example demonstrates how an interceptor can return an error before the request
/// has been dispatched, and how to match on it at the place where it is invoked.
///
/// The example assumes that the Pokemon service is running on the localhost on TCP port 13734.
/// Refer to the [README.md](https://github.com/awslabs/smithy-rs/tree/main/examples/pokemon-service-client-usage/README.md)
/// file for instructions on how to launch the service locally.
///
/// The example can be run using `cargo run --example use-config-bag`.
///
use tracing::{debug, error, info};

use aws_smithy_client::SdkError;
use pokemon_service_client::{config::Interceptor, Client as PokemonClient};
use pokemon_service_client_usage::setup_tracing_subscriber;

static BASE_URL: &str = "http://localhost:13734";

#[derive(Debug, thiserror::Error)]
enum CustomErrors {
    #[error("A required header `{0}` has not been set on the request")]
    HeaderMissing(String),
}

#[derive(Debug, Default)]
pub struct CheckHeaderInterceptor;

impl CheckHeaderInterceptor {
    /// Creates a new `CheckHeaderInterceptor`
    pub fn new() -> Self {
        Self::default()
    }
}

impl Interceptor for CheckHeaderInterceptor {
    fn name(&self) -> &'static str {
        "CheckHeaderInterceptor"
    }

    fn read_before_signing(
        &self,
        context: &pokemon_service_client::config::interceptors::BeforeTransmitInterceptorContextRef<
            '_,
        >,
        _runtime_components: &pokemon_service_client::config::RuntimeComponents,
        _cfg: &mut aws_smithy_types::config_bag::ConfigBag,
    ) -> Result<(), aws_smithy_runtime_api::box_error::BoxError> {
        // Header to check that each request has this set.
        const HEADER_TO_CHECK: hyper::header::HeaderName =
            hyper::header::HeaderName::from_static("x-amzn-date");

        if !context
            .request()
            .headers()
            .iter()
            .any(|(ref header_name, _)| *header_name == HEADER_TO_CHECK)
        {
            debug!("Header not found in request, raising an error");

            return Err(Box::new(CustomErrors::HeaderMissing(
                HEADER_TO_CHECK.to_string(),
            )));
        }

        Ok(())
    }
}

/// Creates a new Smithy client that is configured to communicate with a locally running Pokemon service on TCP port 13734.
///
/// # Examples
///
/// Basic usage:
///
/// ```
/// let client = create_client();
/// ```
fn create_client() -> PokemonClient {
    // The generated client has a type config::Builder that can be used to build a Config, which
    // allows configuring endpoint-resolver, timeouts, retries etc.
    let config = pokemon_service_client::Config::builder()
        .endpoint_resolver(BASE_URL)
        .interceptor(CheckHeaderInterceptor {})
        .build();

    // Apply the configuration on the Client, and return that.
    PokemonClient::from_conf(config)
}

#[tokio::main]
async fn main() {
    setup_tracing_subscriber();

    // Create a configured Smithy client.
    let client = create_client();

    // Call an operation `get_server_statistics` on Pokemon service.
    let response_result = client.get_server_statistics().send().await;

    match response_result {
        Ok(response) => {
            info!(%BASE_URL, ?response, "Response received");
        }
        Err(SdkError::ServiceError(ref e)) => {
            error!(?e, "Service error");
        }
        Err(SdkError::DispatchFailure(de)) => {
            // Any custom error produced by the interceptor will follow a hierarchy:
            // ConnectorError -> InterceptorError -> CustomErrors.
            let custom_error = de
                .as_connector_error()
                // Get the source of the ConnectorError
                .and_then(|connect_error| connect_error.source())
                // And then, maybe it is an InterceptorError, so get the source of it.
                .and_then(|interceptor_error| interceptor_error.source())
                // And then, downcast the InterceptorError's source into a CustomErrors enum.
                .and_then(|custom_error| custom_error.downcast_ref::<CustomErrors>());

            if let Some(custom_error) = custom_error {
                match custom_error {
                    e @ CustomErrors::HeaderMissing(_missing_header) => {
                        // While we're only logging the error in this instance, you can implement
                        // specific logic to handle the error generated by the interceptor.
                        error!("{e}");
                    }
                }
            } else {
                error!(?de, "A dispatch error occurred");
            }
        }
        Err(some_error) => {
            error!(?some_error, "A generic error occurred");
        }
    }
}
