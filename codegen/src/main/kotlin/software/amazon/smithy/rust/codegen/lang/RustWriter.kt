/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

package software.amazon.smithy.rust.codegen.lang

import java.util.function.BiFunction
import software.amazon.smithy.codegen.core.CodegenException
import software.amazon.smithy.codegen.core.Symbol
import software.amazon.smithy.codegen.core.writer.CodegenWriter
import software.amazon.smithy.codegen.core.writer.CodegenWriterFactory
import software.amazon.smithy.model.shapes.Shape
import software.amazon.smithy.model.shapes.ShapeId
import software.amazon.smithy.model.traits.EnumTrait
import software.amazon.smithy.rust.codegen.smithy.RuntimeType
import software.amazon.smithy.rust.codegen.smithy.isOptional
import software.amazon.smithy.rust.codegen.smithy.rustType
import software.amazon.smithy.utils.CodeWriter

fun <T : CodeWriter> T.withBlock(textBeforeNewLine: String, textAfterNewLine: String, block: T.() -> Unit): T {
    openBlock(textBeforeNewLine)
    block(this)
    closeBlock(textAfterNewLine)
    return this
}

/*
 * Writes a Rust-style block, demarcated by curly braces
 */
fun <T : CodeWriter> T.rustBlock(header: String, vararg args: Any, block: T.() -> Unit): T {
    openBlock("$header {", *args)
    block(this)
    closeBlock("}")
    return this
}

class RustWriter(filename: String, private val namespace: String, private val commentCharacter: String = "//") : CodegenWriter<RustWriter, UseDeclarations>(null, UseDeclarations(filename, namespace)) {
    private val formatter = RustSymbolFormatter()
    private var n = 0
    init {
        putFormatter('T', formatter)
    }

    fun safeName(prefix: String = "var"): String {
        n += 1
        return "${prefix}_$n"
    }

    // TODO: refactor both of these methods & add a parent method to for_each across any field type
    // generically
    fun OptionForEach(member: Symbol, outerField: String, block: CodeWriter.(field: String) -> Unit) {
        if (member.isOptional()) {
            val derefName = safeName("inner")
            // TODO: `inner` should be custom codegenned to avoid shadowing
            rustBlock("if let Some($derefName) = $outerField") {
                block(derefName)
            }
        } else {
            this.block(outerField)
        }
    }

    fun ListForEach(target: Shape, outerField: String, block: CodeWriter.(field: String, target: ShapeId) -> Unit) {
        if (target.isListShape) {
            val derefName = safeName("inner")
            rustBlock("for $derefName in $outerField") {
                block(derefName, target.asListShape().get().member.target)
            }
        } else {
            this.block(outerField, target.toShapeId())
        }
    }

    override fun toString(): String {
        val contents = super.toString()
        // Hack to support TOML
        // TODO: consider creating a TOML writer
        val header = "$commentCharacter Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT."
        val useDecls = importContainer.toString()
        return "$header\n$useDecls\n$contents\n"
    }

    fun format(r: Any): String {
        return formatter.apply(r, "")
    }

    fun useAs(target: Shape, base: String): String {
        return if (target.hasTrait(EnumTrait::class.java)) {
            "$base.as_str()"
        } else {
            base
        }
    }

    inner class RustSymbolFormatter : BiFunction<Any, String, String> {
        override fun apply(t: Any, u: String): String {
            return when (t) {
                is RuntimeType -> {
                    t.dependency?.also { addDependency(it) }
                    // for now, use the fully qualified type name
                    "::${t.namespace}::${t.name}"
                }
                is Symbol -> {
                    if (t.namespace != namespace) {
                        addImport(t, null)
                    }
                    t.rustType().render()
                }
                else -> throw CodegenException("Invalid type provided to RustSymbolFormatter")
            }
        }
    }

    companion object {
        val Factory: CodegenWriterFactory<RustWriter> =
            CodegenWriterFactory<RustWriter> { filename, namespace -> when {
                filename.endsWith(".toml") -> RustWriter(filename, namespace, "#")
                else -> RustWriter(filename, namespace)
            } }
    }
}
