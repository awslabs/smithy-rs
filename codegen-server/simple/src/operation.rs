// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Operation shape for `Healthcheck`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct Healthcheck {
    _private: (),
}
impl Healthcheck {
    /// Creates a new `Healthcheck` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub struct HealthcheckOperationInputWrapper(pub crate::input::HealthcheckInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for HealthcheckOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        Ok(HealthcheckOperationInputWrapper(
            crate::operation_deser::parse_healthcheck_request(req).await?,
        ))
    }
}
pub struct HealthcheckOperationOutputWrapper(pub crate::output::HealthcheckOutput);
#[axum::async_trait]
impl axum::response::IntoResponse for HealthcheckOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match crate::operation_ser::serialize_healthcheck_response(&self.0) {
            Ok(response) => response,
            Err(e) => http::Response::builder()
                .body(Self::Body::from(e.to_string()))
                .expect("unable to build response from output"),
        }
    }
}
impl From<crate::output::HealthcheckOutput> for HealthcheckOperationOutputWrapper {
    fn from(o: crate::output::HealthcheckOutput) -> Self {
        Self(o)
    }
}
impl From<HealthcheckOperationInputWrapper> for crate::input::HealthcheckInput {
    fn from(i: HealthcheckOperationInputWrapper) -> Self {
        i.0
    }
}

/// Operation shape for `RegisterService`.
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterService {
    _private: (),
}
impl RegisterService {
    /// Creates a new `RegisterService` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
pub struct RegisterServiceOperationInputWrapper(pub crate::input::RegisterServiceInput);
#[axum::async_trait]
impl<B> axum::extract::FromRequest<B> for RegisterServiceOperationInputWrapper
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Rejection = aws_smithy_http_server::rejection::SmithyRejection;
    async fn from_request(
        req: &mut axum::extract::RequestParts<B>,
    ) -> Result<Self, Self::Rejection> {
        Ok(RegisterServiceOperationInputWrapper(
            crate::operation_deser::parse_register_service_request(req).await?,
        ))
    }
}
pub enum RegisterServiceOperationOutputWrapper {
    Output(crate::output::RegisterServiceOutput),
    Error(crate::error::RegisterServiceError),
}
#[axum::async_trait]
impl axum::response::IntoResponse for RegisterServiceOperationOutputWrapper {
    type Body = aws_smithy_http_server::Body;
    type BodyError = <Self::Body as aws_smithy_http_server::HttpBody>::Error;

    fn into_response(self) -> http::Response<Self::Body> {
        match self {
            Self::Output(o) => {
                match crate::operation_ser::serialize_register_service_response(&o) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from output"),
                }
            }
            Self::Error(err) => {
                match crate::operation_ser::serialize_register_service_error(&err) {
                    Ok(response) => response,
                    Err(e) => http::Response::builder()
                        .body(Self::Body::from(e.to_string()))
                        .expect("unable to build response from error"),
                }
            }
        }
    }
}
impl From<Result<crate::output::RegisterServiceOutput, crate::error::RegisterServiceError>>
    for RegisterServiceOperationOutputWrapper
{
    fn from(
        res: Result<crate::output::RegisterServiceOutput, crate::error::RegisterServiceError>,
    ) -> Self {
        match res {
            Ok(v) => Self::Output(v),
            Err(e) => Self::Error(e),
        }
    }
}
impl From<RegisterServiceOperationInputWrapper> for crate::input::RegisterServiceInput {
    fn from(i: RegisterServiceOperationInputWrapper) -> Self {
        i.0
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod server_register_service_test {
    /// Test ID: RegisterServiceRequestTest
    #[tokio::test]
    async fn register_service_request_test_request() {
        let expected = crate::input::RegisterServiceInput::builder()
            .set_id(Some("1".to_string()))
            .set_name(Some("TestService".to_string()))
            .build()
            .unwrap();
        let http_request = http::Request::builder()
            .uri("/service/1")
            .header("Content-Type", "application/json")
            .body(aws_smithy_http_server::Body::from(
                bytes::Bytes::from_static(b"{\"name\":\"TestService\"}"),
            ))
            .unwrap();
        use axum::extract::FromRequest;
        let mut http_request = axum::extract::RequestParts::new(http_request);
        let input_wrapper =
            super::RegisterServiceOperationInputWrapper::from_request(&mut http_request)
                .await
                .expect("failed to parse request");
        let input = input_wrapper.0;
        assert_eq!(input, expected);
    }
    /// Test ID: RegisterServiceResponseTest
    #[tokio::test]
    async fn register_service_response_test_response() {
        let output = crate::output::RegisterServiceOutput::builder()
            .set_id(Some("1".to_string()))
            .set_name(Some("TestService".to_string()))
            .build();
        let output = super::RegisterServiceOperationOutputWrapper::Output(output);
        use axum::response::IntoResponse;
        let http_response = output.into_response();
        assert_eq!(
            http::StatusCode::from_u16(200).expect("invalid expected HTTP status code"),
            http_response.status()
        );
        let body = hyper::body::to_bytes(http_response.into_body())
            .await
            .expect("unable to extract body to bytes");
        assert_eq!("{\"id\":\"1\",\"name\":\"TestService\"}", body);
    }
}
