use std::future::Future;

use crate::error::*;
use crate::input::*;
use crate::operation::*;
use crate::output::*;
use aws_smithy_http_server::body::{box_body, BoxBody};
use aws_smithy_http_server::opaque_future;
use aws_smithy_http_server::routing::request_spec::{
    PathAndQuerySpec, PathSegment, PathSpec, QuerySegment, QuerySpec, UriSpec,
};
use aws_smithy_http_server::routing::{request_spec::RequestSpec, Router};
use aws_smithy_http_server::Extension;
use axum::extract::FromRequest;
use axum::extract::RequestParts;
use axum::response::IntoResponse;
use futures_util::{
    future::{BoxFuture, Map},
    FutureExt,
};
use http::{Request, Response};
use std::marker::PhantomData;
use std::{
    convert::Infallible,
    task::{Context, Poll},
};
use tower::Service;

/// Struct that holds a handler, that is, a function provided by the user that implements the
/// Smithy operation.
pub struct OperationHandler<H, B, R, I> {
    handler: H,
    #[allow(clippy::type_complexity)]
    _marker: PhantomData<fn() -> (B, R, I)>,
}

impl<H, B, R, I> Clone for OperationHandler<H, B, R, I>
where
    H: Clone,
{
    fn clone(&self) -> Self {
        Self {
            handler: self.handler.clone(),
            _marker: PhantomData,
        }
    }
}

/// Construct an [`OperationHandler`] out of a function implementing the operation.
pub fn operation<H, B, R, I>(handler: H) -> OperationHandler<H, B, R, I> {
    OperationHandler {
        handler,
        _marker: PhantomData,
    }
}

impl<H, B, R, I> Service<Request<B>> for OperationHandler<H, B, R, I>
where
    H: Handler<B, R, I>,
    B: Send + 'static,
{
    type Response = Response<BoxBody>;
    type Error = Infallible;
    type Future = OperationHandlerFuture;

    #[inline]
    fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: Request<B>) -> Self::Future {
        let future = Handler::call(self.handler.clone(), req).map(Ok::<_, Infallible> as _);
        OperationHandlerFuture::new(future)
    }
}

type WrapResultInResponseFn = fn(Response<BoxBody>) -> Result<Response<BoxBody>, Infallible>;

opaque_future! {
    /// Response future for [`OperationHandler`].
    pub type OperationHandlerFuture =
        Map<BoxFuture<'static, Response<BoxBody>>, WrapResultInResponseFn>;
}

pub(crate) mod sealed {
    #![allow(unreachable_pub, missing_docs, missing_debug_implementations)]
    pub trait HiddenTrait {}
    pub struct Hidden;
    impl HiddenTrait for Hidden {}
}

#[axum::async_trait]
pub trait Handler<B, T, Fut>: Clone + Send + Sized + 'static {
    #[doc(hidden)]
    type Sealed: sealed::HiddenTrait;

    async fn call(self, req: Request<B>) -> Response<BoxBody>;
}

// Implementations code-generated by smithy-rs below.

#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), HealthcheckInput> for Fun
where
    Fun: FnOnce(HealthcheckInput) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = HealthcheckOutput> + Send,
    B: Send + 'static + aws_smithy_http_server::HttpBody,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;

    async fn call(self, _req: Request<B>) -> Response<BoxBody> {
        todo!()
    }
}

#[axum::async_trait]
impl<B, Fun, Fut, S> Handler<B, Extension<S>, HealthcheckInput> for Fun
where
    Fun: FnOnce(HealthcheckInput, Extension<S>) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = HealthcheckOutput> + Send,
    S: Send + Sync + Clone + 'static,
    B: Send + 'static + aws_smithy_http_server::HttpBody,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;

    async fn call(self, req: Request<B>) -> Response<BoxBody> {
        let mut req = RequestParts::new(req);

        let wrapper = match HealthcheckOperationInputWrapper::from_request(&mut req).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response().map(box_body),
        };

        let state = match Extension::<S>::from_request(&mut req).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response().map(box_body),
        };

        let input_inner = wrapper.into();
        let output_inner = self(input_inner, state).await;
        let output_wrapper: HealthcheckOperationOutputWrapper = output_inner.into();

        output_wrapper.into_response().map(box_body)
    }
}

#[axum::async_trait]
impl<B, Fun, Fut> Handler<B, (), RegisterServiceInput> for Fun
where
    Fun: FnOnce(RegisterServiceInput) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = Result<RegisterServiceOutput, RegisterServiceError>> + Send,
    B: Send + 'static + aws_smithy_http_server::HttpBody,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;

    async fn call(self, req: Request<B>) -> Response<BoxBody> {
        let mut req = RequestParts::new(req);

        let wrapper = match RegisterServiceOperationInputWrapper::from_request(&mut req).await {
            Ok(value) => value,
            Err(rejection) => return rejection.into_response().map(box_body),
        };

        let input_inner = wrapper.into();
        let output_inner = self(input_inner).await;
        let output_wrapper: RegisterServiceOperationOutputWrapper = output_inner.into();

        output_wrapper.into_response().map(box_body)
    }
}

#[axum::async_trait]
impl<B, Fun, Fut, S> Handler<B, Extension<S>, RegisterServiceInput> for Fun
where
    Fun: FnOnce(RegisterServiceInput, Extension<S>) -> Fut + Clone + Send + 'static,
    Fut: Future<Output = RegisterServiceOutput> + Send,
    S: Send + Clone + Sync + 'static,
    B: Send + 'static + aws_smithy_http_server::HttpBody,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    type Sealed = sealed::Hidden;

    async fn call(self, _req: Request<B>) -> Response<BoxBody> {
        todo!()
    }
}

pub struct SimpleServiceOperationRegistry<B, Op1, In1, Op2, In2> {
    pub health_check: Op1,
    pub register_service: Op2,
    _phantom: PhantomData<(Op1, Op2, B, In1, In2)>,
}

#[allow(clippy::all)]
///Builder for [`SimpleServiceOperationRegistry`](struct.SimpleServiceOperationRegistry.html).
pub struct SimpleServiceOperationRegistryBuilder<B, Op1, In1, Op2, In2> {
    health_check: Option<Op1>,
    register_service: Option<Op2>,
    _phantom: PhantomData<(Op1, Op2, B, In1, In2)>,
}
#[allow(clippy::all)]
#[allow(dead_code)]
impl<B, Op1, In1, Op2, In2> SimpleServiceOperationRegistryBuilder<B, Op1, In1, Op2, In2> {
    #[allow(unused_mut)]
    pub fn health_check(self, value: Op1) -> Self {
        let mut new = self;
        new.health_check = Some(value);
        new
    }
    #[allow(unused_mut)]
    pub fn register_service(self, value: Op2) -> Self {
        let mut new = self;
        new.register_service = Some(value);
        new
    }
    ///Builds a new `SimpleServiceOperationRegistry`.
    ///
    ///# Errors
    ///
    ///If a required field has not been initialized.
    pub fn build(
        self,
    ) -> Result<
        SimpleServiceOperationRegistry<B, Op1, In1, Op2, In2>,
        SimpleServiceOperationRegistryBuilderError,
    > {
        Ok(SimpleServiceOperationRegistry {
            health_check: match self.health_check {
                Some(value) => value,
                None => {
                    return Err(
                        SimpleServiceOperationRegistryBuilderError::UninitializedField(
                            "health_check",
                        ),
                    )
                }
            },
            register_service: match self.register_service {
                Some(value) => value,
                None => {
                    return Err(
                        SimpleServiceOperationRegistryBuilderError::UninitializedField(
                            "register_service",
                        ),
                    )
                }
            },
            _phantom: PhantomData,
        })
    }
}
impl<B, Op1, In1, Op2, In2> Default
    for SimpleServiceOperationRegistryBuilder<B, Op1, In1, Op2, In2>
{
    fn default() -> Self {
        Self {
            health_check: Default::default(),
            register_service: Default::default(),
            _phantom: PhantomData,
        }
    }
}
///Error type for SimpleServiceOperationRegistryBuilder
#[non_exhaustive]
#[derive(Debug)]
pub enum SimpleServiceOperationRegistryBuilderError {
    /// Uninitialized field
    UninitializedField(&'static str),
}
impl std::error::Error for SimpleServiceOperationRegistryBuilderError {}
impl core::fmt::Display for SimpleServiceOperationRegistryBuilderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UninitializedField(v) => write!(f, "{}", v),
        }
    }
}

// ==================================================================
// END of `cargo expand`ed from `derive_builder` and cleaned up a bit
// ==================================================================

impl<B, Op1, In1, Op2, In2> From<SimpleServiceOperationRegistry<B, Op1, In1, Op2, In2>>
    for Router<B>
where
    B: Send + 'static,
    Op1: Handler<B, In1, HealthcheckInput>,
    In1: 'static,
    Op2: Handler<B, In2, RegisterServiceInput>,
    In2: 'static,
{
    fn from(registry: SimpleServiceOperationRegistry<B, Op1, In1, Op2, In2>) -> Self {
        // `http localhost:8080/path/to/label/healthcheck`
        let health_check_request_spec = RequestSpec::new(
            http::Method::GET,
            UriSpec {
                host_prefix: None,
                path_and_query: PathAndQuerySpec {
                    path_segments: PathSpec::from_vector_unchecked(vec![
                        PathSegment::Literal(String::from("path")),
                        PathSegment::Literal(String::from("to")),
                        PathSegment::Label,
                        PathSegment::Literal(String::from("healthcheck")),
                    ]),
                    query_segments: QuerySpec::from_vector_unchecked(Vec::new()),
                },
            },
        );

        // `http POST "localhost:8080/register-service/gre/ee/dy/suffix?key&foo=bar"`
        let register_service_request_spec = RequestSpec::new(
            http::Method::POST,
            UriSpec {
                host_prefix: None,
                path_and_query: PathAndQuerySpec {
                    path_segments: PathSpec::from_vector_unchecked(vec![
                        PathSegment::Literal(String::from("register-service")),
                        PathSegment::Greedy,
                        PathSegment::Literal(String::from("suffix")),
                    ]),
                    query_segments: QuerySpec::from_vector_unchecked(vec![
                        QuerySegment::Key(String::from("key")),
                        QuerySegment::KeyValue(String::from("foo"), String::from("bar")),
                    ]),
                },
            },
        );

        let op1 = operation(registry.health_check);
        let op2 = operation(registry.register_service);
        Router::new()
            .route(health_check_request_spec, op1)
            .route(register_service_request_spec, op2)
    }
}
