/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package software.amazon.smithy.rust.codegen.server.smithy.protocols.serialize

import org.junit.jupiter.api.Test
import software.amazon.smithy.model.Model
import software.amazon.smithy.model.shapes.BlobShape
import software.amazon.smithy.model.shapes.CollectionShape
import software.amazon.smithy.model.shapes.ListShape
import software.amazon.smithy.model.shapes.MapShape
import software.amazon.smithy.model.shapes.MemberShape
import software.amazon.smithy.model.shapes.NumberShape
import software.amazon.smithy.model.shapes.OperationShape
import software.amazon.smithy.model.shapes.Shape
import software.amazon.smithy.model.shapes.ShapeId
import software.amazon.smithy.model.shapes.StringShape
import software.amazon.smithy.model.shapes.StructureShape
import software.amazon.smithy.model.shapes.TimestampShape
import software.amazon.smithy.model.shapes.UnionShape
import software.amazon.smithy.model.traits.ErrorTrait
import software.amazon.smithy.model.transform.ModelTransformer
import software.amazon.smithy.protocoltests.traits.AppliesTo
import software.amazon.smithy.rust.codegen.core.rustlang.Attribute
import software.amazon.smithy.rust.codegen.core.rustlang.CargoDependency
import software.amazon.smithy.rust.codegen.core.rustlang.DependencyScope
import software.amazon.smithy.rust.codegen.core.rustlang.RustMetadata
import software.amazon.smithy.rust.codegen.core.rustlang.RustWriter
import software.amazon.smithy.rust.codegen.core.rustlang.rustTemplate
import software.amazon.smithy.rust.codegen.core.smithy.CodegenContext
import software.amazon.smithy.rust.codegen.core.smithy.RuntimeType
import software.amazon.smithy.rust.codegen.core.smithy.RustSymbolProvider
import software.amazon.smithy.rust.codegen.core.smithy.SymbolMetadataProvider
import software.amazon.smithy.rust.codegen.core.smithy.expectRustMetadata
import software.amazon.smithy.rust.codegen.core.smithy.generators.protocol.FailingTest
import software.amazon.smithy.rust.codegen.core.smithy.generators.protocol.ProtocolSupport
import software.amazon.smithy.rust.codegen.core.smithy.generators.protocol.ProtocolTestGenerator
import software.amazon.smithy.rust.codegen.core.smithy.generators.protocol.ServiceShapeId.RPC_V2_CBOR
import software.amazon.smithy.rust.codegen.core.smithy.generators.protocol.TestCase
import software.amazon.smithy.rust.codegen.core.smithy.protocols.ProtocolFunctions
import software.amazon.smithy.rust.codegen.core.testutil.IntegrationTestParams
import software.amazon.smithy.rust.codegen.core.testutil.unitTest
import software.amazon.smithy.rust.codegen.core.util.UNREACHABLE
import software.amazon.smithy.rust.codegen.core.util.hasTrait
import software.amazon.smithy.rust.codegen.core.util.toSnakeCase
import software.amazon.smithy.rust.codegen.server.smithy.ServerCodegenContext
import software.amazon.smithy.rust.codegen.server.smithy.customize.ServerCodegenDecorator
import software.amazon.smithy.rust.codegen.server.smithy.generators.ServerInstantiator
import software.amazon.smithy.rust.codegen.server.smithy.generators.protocol.ServerProtocolTestGenerator
import software.amazon.smithy.rust.codegen.server.smithy.generators.protocol.ServerRpcV2CborProtocol
import software.amazon.smithy.rust.codegen.server.smithy.protocols.ServerRpcV2CborFactory
import software.amazon.smithy.rust.codegen.server.smithy.testutil.serverIntegrationTest
import java.util.function.Predicate

/**
 * This lives in `codegen-server` because we want to run a full integration test for convenience,
 * but there's really nothing server-specific here. We're just testing that the CBOR (de)serializers work like
 * the ones generated by `serde_cbor`. This is a good exhaustive litmus test for correctness, since `serde_cbor`
 * is battle-tested.
 */
internal class CborSerializerAndParserGeneratorSerdeRoundTripIntegrationTest {
    class DeriveSerdeDeserializeSymbolMetadataProvider(
        private val base: RustSymbolProvider,
    ) : SymbolMetadataProvider(base) {
        private val serdeDeserialize =
            CargoDependency.Serde.copy(scope = DependencyScope.Compile).toType().resolve("Deserialize")

        private fun addDeriveSerdeDeserialize(shape: Shape): RustMetadata {
            check(shape !is MemberShape)

            val baseMetadata = base.toSymbol(shape).expectRustMetadata()
            return baseMetadata.withDerives(serdeDeserialize)
        }

        override fun memberMeta(memberShape: MemberShape): RustMetadata {
            val baseMetadata = base.toSymbol(memberShape).expectRustMetadata()
            return baseMetadata.copy(
                additionalAttributes = baseMetadata.additionalAttributes + Attribute(
                    """serde(rename = "${memberShape.memberName}")""",
                    isDeriveHelper = true,
                ),
            )
        }

        override fun structureMeta(structureShape: StructureShape) = addDeriveSerdeDeserialize(structureShape)
        override fun unionMeta(unionShape: UnionShape) = addDeriveSerdeDeserialize(unionShape)
        override fun enumMeta(stringShape: StringShape) = addDeriveSerdeDeserialize(stringShape)

        override fun listMeta(listShape: ListShape): RustMetadata = addDeriveSerdeDeserialize(listShape)
        override fun mapMeta(mapShape: MapShape): RustMetadata = addDeriveSerdeDeserialize(mapShape)
        override fun stringMeta(stringShape: StringShape): RustMetadata = addDeriveSerdeDeserialize(stringShape)
        override fun numberMeta(numberShape: NumberShape): RustMetadata = addDeriveSerdeDeserialize(numberShape)
        override fun blobMeta(blobShape: BlobShape): RustMetadata = addDeriveSerdeDeserialize(blobShape)
    }

    @Test
    fun `we serialize and serde_cbor deserializes round trip`() {
        val addDeriveSerdeSerializeDecorator = object : ServerCodegenDecorator {
            override val name: String = "Add `#[derive(serde::Deserialize)]`"
            override val order: Byte = 0

            override fun symbolProvider(base: RustSymbolProvider): RustSymbolProvider =
                DeriveSerdeDeserializeSymbolMetadataProvider(base)
        }

        // Don't generate protocol tests, because it'll attempt to pull out `params` for member shapes we'll remove
        // from the model.
        val noProtocolTestsDecorator = object : ServerCodegenDecorator {
            override val name: String = "Don't generate protocol tests"
            override val order: Byte = 0

            override fun protocolTestGenerator(
                codegenContext: ServerCodegenContext,
                baseGenerator: ProtocolTestGenerator
            ): ProtocolTestGenerator {
                val noOpProtocolTestsGenerator = object : ProtocolTestGenerator() {
                    override val codegenContext: CodegenContext
                        get() = baseGenerator.codegenContext
                    override val protocolSupport: ProtocolSupport
                        get() = baseGenerator.protocolSupport
                    override val operationShape: OperationShape
                        get() = baseGenerator.operationShape
                    override val appliesTo: AppliesTo
                        get() = baseGenerator.appliesTo
                    override val expectFail: Set<FailingTest>
                        get() = baseGenerator.expectFail
                    override val runOnly: Set<String>
                        get() = baseGenerator.runOnly
                    override val disabledTests: Set<String>
                        get() = baseGenerator.disabledTests

                    override fun RustWriter.renderAllTestCases(allTests: List<TestCase>) {
                        // No-op.
                    }

                }
                return noOpProtocolTestsGenerator
            }
        }

        val model = Model.assembler().discoverModels().assemble().result.get()

        // Filter out `timestamp` and `blob` shapes: those map to runtime types in `aws-smithy-types` on
        // which we can't `#[derive(serde::Deserialize)]`.
        // Note we can't use `ModelTransformer.removeShapes` because it will leave the model in an inconsistent state
        // when removing list/set shape member shapes.
        val removeTimestampAndBlobShapes: Predicate<Shape> = Predicate { shape ->
            when (shape) {
                is MemberShape -> {
                    val targetShape = model.expectShape(shape.target)
                    targetShape is BlobShape || targetShape is TimestampShape
                }
                is BlobShape, is TimestampShape -> true
                is CollectionShape  -> {
                    val targetShape = model.expectShape(shape.member.target)
                    targetShape is BlobShape || targetShape is TimestampShape
                }
                else -> false
            }
        }
        fun removeShapesByShapeId(shapeIds: Set<ShapeId>): Predicate<Shape> {
            val predicate: Predicate<Shape> = Predicate { shape ->
                when (shape) {
                    is MemberShape -> {
                        val targetShape = model.expectShape(shape.target)
                        shapeIds.contains(targetShape.id)
                    }
                    is CollectionShape  -> {
                        val targetShape = model.expectShape(shape.member.target)
                        shapeIds.contains(targetShape.id)
                    }
                    else -> {
                        shapeIds.contains(shape.id)
                    }
                }
            }
            return predicate
        }


        val modelTransformer = ModelTransformer.create()
        val transformedModel = modelTransformer.removeShapesIf(
            modelTransformer.removeShapesIf(model, removeTimestampAndBlobShapes),
            // These enums do not serialize their variants using the Rust members' names.
            // We'd have to tack on `#[serde(rename = "name")]` using the proper name defined in the Smithy enum definition.
            // But we have no way of injecting that attribute on Rust enum variants in the code generator.
            // So we just remove these problematic shapes.
            removeShapesByShapeId(
                setOf(
                    ShapeId.from("smithy.protocoltests.shared#FooEnum"),
                    ShapeId.from("smithy.protocoltests.rpcv2Cbor#TestEnum"),
                ),
            ),
        )

        val serviceShape = transformedModel.expectShape(ShapeId.from(RPC_V2_CBOR))
        serverIntegrationTest(
            transformedModel,
            additionalDecorators = listOf(addDeriveSerdeSerializeDecorator, noProtocolTestsDecorator),
            params = IntegrationTestParams(service = serviceShape.id.toString())
        ) { codegenContext, rustCrate ->
            // TODO(https://github.com/smithy-lang/smithy-rs/issues/1147): NaN != NaN. Ideally we when we address
            //  this issue, we'd re-use the structure shape comparison code that both client and server protocol test
            //  generators would use.
            val expectFail = setOf("RpcV2CborSupportsNaNFloatOutputs")

            val codegenScope = arrayOf(
                "AssertEq" to RuntimeType.PrettyAssertions.resolve("assert_eq!"),
                "SerdeCbor" to CargoDependency.SerdeCbor.toType(),
            )

            val instantiator = ServerInstantiator(codegenContext, ignoreMissingMembers = true)
            val rpcV2 = ServerRpcV2CborProtocol(codegenContext)

            for (operationShape in codegenContext.model.operationShapes) {
                val serverProtocolTestGenerator =
                    ServerProtocolTestGenerator(codegenContext, ServerRpcV2CborFactory().support(), operationShape)
                // The SDK can only serialize operation outputs, so we only ask for response tests.
                val tests =
                    serverProtocolTestGenerator.responseTestCases()

                rustCrate.withModule(ProtocolFunctions.serDeModule) {
                    for (test in tests) {
                        when (test) {
                            is TestCase.MalformedRequestTest -> UNREACHABLE("we did not ask for tests of this kind")
                            is TestCase.RequestTest -> UNREACHABLE("we did not ask for tests of this kind")
//                            is TestCase.RequestTest -> operationShape.inputShape(codegenContext.model) to test.testCase.params
                            is TestCase.ResponseTest -> {
                                val targetShape = test.targetShape
                                val params = test.testCase.params

                                val serializeFn = if (targetShape.hasTrait<ErrorTrait>()) {
                                    rpcV2.structuredDataSerializer().serverErrorSerializer(targetShape.id)
                                } else {
                                    rpcV2.structuredDataSerializer().operationOutputSerializer(operationShape)
                                }

                                if (serializeFn == null) {
                                    // Skip if there's nothing to serialize.
                                    continue
                                }

                                if (expectFail.contains(test.id)) {
                                    writeWithNoFormatting("#[should_panic]")
                                }
                                unitTest("we_serialize_and_serde_cbor_deserializes_${test.id.toSnakeCase()}_${test.kind.toString().toSnakeCase()}") {
                                    rustTemplate(
                                        """
                                        let expected = #{InstantiateShape:W};
                                        let bytes = #{SerializeFn}(&expected)
                                            .expect("generated CBOR serializer failed");
                                        let actual = #{SerdeCbor}::from_slice(&bytes)
                                           .expect("serde_cbor failed deserializing from bytes");
                                        #{AssertEq}(expected, actual);
                                        """,
                                        "InstantiateShape" to instantiator.generate(targetShape, params),
                                        "SerializeFn" to serializeFn,
                                        *codegenScope,
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
