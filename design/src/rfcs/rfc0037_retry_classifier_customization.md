# RFC: User-configurable retry classification

> Status: RFC
>
> Applies to: client

For a summarized list of proposed changes, see the [Changes Checklist](#changes-checklist) section.

This RFC defines the user experience and implementation of user-configurable
retry classification. Custom retry classifiers enable users to change what
responses are retried while still allowing them to rely on defaults set by SDK
authors when desired.
## Terminology

- **Smithy Service**: An HTTP service, whose API is modeled with the [Smithy
  IDL](https://www.smithy.io).
- **Smithy Client**: An HTTP client generated by smithy-rs from a `.smithy`
  model file.
- **AWS SDK**: A **smithy client** that's specifically configured to work with
  an AWS service.
- **Operation**: A modeled interaction with a service, defining the proper input
  and expected output shapes, as well as important metadata related to request
  construction. "Sending" an operation implies sending one or more HTTP requests
  to a **Smithy service**, and then receiving an output or error in response.
- **Orchestrator**: The client code which manages the request/response pipeline.
  The orchestrator is responsible for:
    - Constructing, serializing, and sending requests.
    - Receiving, deserializing, and (optionally) retrying requests.
    - Running interceptors *(not covered in this RFC)* and handling errors.
- **Runtime Component**: A part of the orchestrator responsible for a specific
  function. Runtime components are used by the orchestrator itself, may depend
  on specific configuration, and must not be changed by interceptors. Examples
  include the endpoint resolver, retry strategy, and request signer.
- **Runtime Plugin**: Code responsible for setting and **runtime components**
  and related configuration. Runtime plugins defined by codegen are responsible
  for setting default configuration and altering the behavior of **Smithy
  clients** including the **AWS SDKs**.

## How the orchestrator should model retries

A **Retry Strategy** is the process by which the orchestrator determines when
and how to retry failed requests. Only one retry strategy may be set at any
given time. During its operation, the retry strategy relies on a series of
**Retry Classifiers** to determine if and how a failed request should be
retried. Retry classifiers each have a **Retry Classifier Priority** so that
regardless of whether they are set during config or operation construction,
they'll always run in a consistent order.

Classifiers are each run in turn by the retry strategy:

```rust
pub fn run_classifiers_on_ctx(
    classifiers: impl Iterator<Item = SharedRetryClassifier>,
    ctx: &InterceptorContext,
) -> RetryAction {
    let mut result = None;

    for classifier in classifiers {
        let new_result = classifier.classify_retry(ctx, result.clone());

        // Emit a log whenever a new result overrides the result of a higher-priority classifier.
        if new_result != result && new_result.is_none() {
            tracing::debug!(
                "Classifier '{}' has overridden the result of a higher-priority classifier",
                classifier.name()
            );
        }

        result = new_result;
    }

    result.unwrap_or(RetryAction::NoRetry)
}
```

*NOTE: User-defined retry strategies are responsible for calling `run_classifiers_on_ctx`.*

Lower-priority classifiers have the option of overriding or passing on the
`RetryAction` returned by higher-priority classifiers. However, the default
classifiers set for generic and AWS smithy clients always respect the result of
higher-priority classifiers.

## The user experience if this RFC is implemented

In the current version of the SDK, users are unable to configure retry
classification, except by defining a custom retry strategy. Once this RFC is
implemented, users will be able to define and set their own classifiers.

### Defining a custom classifier

```rust
#[derive(Debug)]
struct CustomRetryClassifier;

impl ClassifyRetry for CustomRetryClassifier {
    fn classify_retry(
        &self,
        ctx: &InterceptorContext,
        preceding_action: Option<RetryAction>,
    ) -> Option<RetryAction> {
        // It's typical, but not required, to respect the judgement of the
        // preceding classifier and forward it on.
        if let Some(action) = preceding_action {
            return action;
        }

        todo!("inspect the interceptor context to determine if a retry attempt should be made.")
    }

    fn name(&self) -> &'static str { "my custom retry classifier" }

    fn priority(&self) -> RetryClassifierPriority {
        RetryClassifierPriority::default()
    }
}
```

#### Choosing a retry classifier priority

Sticking with the default priority is often the best choice. Classifiers should
restrict the number of cases they can handle in order to avoid having to compete
with other classifiers. When two classifiers would classify a response in two
different ways, the priority system gives us the ability to decide which
classifier should be respected.

Internally, priority is implemented with a simple numeric system. In order to
give the smithy-rs team the flexibility to make future changes, this numeric
system is private and inaccessible to users. Instead, users may set the priority
of classifiers relative to one another with the `run_after` and `run_before`
methods:

```rust
impl RetryClassifierPriority {
    /// Create a new `RetryClassifierPriority` that runs after the given priority.
    pub fn run_after(other: Self) -> Self {
        Self::Other(other.as_i8() - 1)
    }

    /// Create a new `RetryClassifierPriority` that runs before the given priority.
    pub fn run_before(other: Self) -> Self {
        Self::Other(other.as_i8() + 1)
    }
}
```

For example, if it was important for our `CustomRetryClassifer` in the previous
example to run *before* the default `HttpStatusCodeClassifier`, a user would
define the `CustomRetryClassifer` priority like this:

```rust
impl ClassifyRetry for CustomRetryClassifier {
    fn priority(&self) -> RetryClassifierPriority {
        RetryClassifierPriority::run_before(RetryClassifierPriority::http_status_code_classifier())
    }
}
```

The priorities of the three default retry classifiers
(`HttpStatusCodeClassifier`, `ModeledAsRetryableClassifier`, and
`TransientErrorClassifier`) are all public for this purpose. Users may **ONLY**
set the priority of a retry relative to an existing retry priority.

### Setting classifiers

The interface for setting classifiers is very similar to the interface of
settings interceptors:

```rust
// All service configs support these setters. Operations support a nearly identical API.
impl ServiceConfigBuilder {
    /// Add type implementing ClassifyRetry that will be used by the RetryStrategy
    /// to determine what responses should be retried.
    ///
    /// A retry classifier configured by this method will run according to its priority.
    pub fn retry_classifier(mut self, retry_classifier: impl ClassifyRetry + 'static) -> Self {
        self.push_retry_classifier(SharedRetryClassifier::new(retry_classifier));
        self
    }

    /// Add a SharedRetryClassifier that will be used by the RetryStrategy to
    /// determine what responses should be retried.
    ///
    /// A retry classifier configured by this method will run according to its priority.
    pub fn push_retry_classifier(&mut self, retry_classifier: SharedRetryClassifier) -> &mut Self {
        self.runtime_components.push_retry_classifier(retry_classifier);
        self
    }

    /// Set SharedRetryClassifiers for the builder, replacing any that were
    /// previously set.
    pub fn set_retry_classifiers(&mut self, retry_classifiers: impl IntoIterator<Item = SharedRetryClassifier>) -> &mut Self {
        self.runtime_components.set_retry_classifiers(retry_classifiers.into_iter());
        self
    }
}
```

### Default classifiers

Smithy clients have three classifiers enabled by default:

- `ModeledAsRetryableClassifier`: Checks for errors that are marked as retryable
  in the smithy model. If one is encountered, returns
  `Some(RetryAction::Retry(ErrorKind))`. Otherwise, returns `None`. Requires a
  parsed response.
- `TransientErrorClassifier`: Checks for timeout, IO, and connector errors. If
  one is encountered, returns
  `Some(RetryAction::Retry(ErrorKind::TransientError))`. Otherwise, returns
  `None`. Requires a parsed response.
- `HttpStatusCodeClassifier`: Checks the HTTP response's status code. By default
  this classifies `500`, `502`, `503`, and `504` errors as
  `Some(RetryAction::Retry(ErrorKind::TransientError))`. Otherwise, returns
  `None`. The list of retryable status codes may be customized when creating
  this classifier with the `HttpStatusCodeClassifier::new_from_codes` method.

AWS clients enable the three smithy classifiers as well as two more by default:

- `AwsErrorCodeClassifier`: Checks for errors with AWS error codes marking them
  as either transient or throttling errors. If one is encountered, returns
  `Some(RetryAction::Retry(ErrorKind))`. Otherwise, returns `None`. Requires a
  parsed response.
- `AmzRetryAfterHeaderClassifier`: Checks the HTTP response for an
  `x-amz-retry-after` header. If one is set, returns
  `Some(RetryAction::RetryAfter(duration))` where duration is the header's
  value. Otherwise, returns `None`.

The priority order of these classifiers is as follows:

1. *(highest priority)* `TransientErrorClassifier`
2. `AmzRetryAfterHeaderClassifier`
3. `ModeledAsRetryableClassifier`
4. `AwsErrorCodeClassifier`
5. *(lowest priority)* `HttpStatusCodeClassifier`

The priority order of the default classifiers is not configurable. However, it's possible to wrap a default classifier in a newtype and set your desired priority when implementing the `ClassifyRetry` trait, delegating the `classify_retry` and `name` fields to the inner classifier.

#### Disable default classifiers

Disabling the default classifiers is possible, but not easy. They are set at different points during config and operation construction, and must be unset at each of those places. A far simpler solution is to implement your own classifier that either:

 - Has the highest priority. All default classifiers will always respect the action of a higher-priority classifier.
 - Has the lowest priority and disregards the action of all other classifiers.

Still, if completely removing the other classifiers is desired, use the `set_retry_classifiers` method on the config to replace the config-level defaults and then set a config override on the operation that does the same.

## How to actually implement this RFC

In order to implement this feature, we must:
- Update the current retry classification system so that individual classifiers as well as collections of classifiers can be easily composed together.
- Create two new configuration mechanisms for users that allow them to customize retry classification at the service level and at the operation level.
- Update retry classifiers so that they may 'short-circuit' the chain, ending retry classification immediately.

### The `RetryClassifier` trait

```rust
/// The result of running a [`ClassifyRetry`] on a [`InterceptorContext`].
#[non_exhaustive]
#[derive(Clone, Eq, PartialEq, Debug)]
pub enum RetryAction {
    /// When an error is received that should be retried, this action is returned.
    Retry(ErrorKind),
    /// When the server tells us to retry after a specific time has elapsed, this action is returned.
    RetryAfter(Duration),
    /// When a response should not be retried, this action is returned.
    NoRetry,
}

/// Classifies what kind of retry is needed for a given [`InterceptorContext`].
pub trait ClassifyRetry: Send + Sync + fmt::Debug {
    /// Run this classifier on the [`InterceptorContext`] to determine if the previous request
    /// should be retried. If the classifier makes a decision, `Some(RetryAction)` is returned.
    /// Classifiers may also return `None`, signifying that they have no opinion of whether or
    /// not a request should be retried.
    fn classify_retry(
        &self,
        ctx: &InterceptorContext,
        preceding_action: Option<RetryAction>,
    ) -> Option<RetryAction>;

    /// The name of this retry classifier.
    ///
    /// Used for debugging purposes.
    fn name(&self) -> &'static str;

    /// The priority of this retry classifier. Classifiers with a higher priority will run before
    /// classifiers with a lower priority. Classifiers with equal priorities make no guarantees
    /// about which will run first.
    fn priority(&self) -> RetryClassifierPriority {
        RetryClassifierPriority::default()
    }
}
```

### Resolving the correct order of multiple retry classifiers

Because each classifier has a defined priority, and because
`RetryClassifierPriority` implements `PartialOrd` and `Ord`, the standard
library's [sort] method may be used to correctly arrange classifiers. The
`RuntimeComponents` struct is responsible for storing classifiers, so it's also
responsible for sorting them whenever a new classifier is added. Thus, when a
retry strategy fetches the list of classifiers, they'll already be in the
expected order.

## Questions and answers

- **Q:** Why are retry classifiers responsible for passing on the result of preceding
classifiers? Isn't this a 'footgun'?
  - **A:** Allowing lower-priority classifiers to second-guess the action returned
by a higher-priority classifier allows users to define "catch-all" classifiers
that run last and have ultimate authority to decide if a response should be
retried.
- **Q:** Should retry classifiers be fallible?
  - **A:** I think no, because of the added complexity. If we make them fallible then we'll have to decide what happens when classifiers fail. Do we skip them or does classification end? The retry strategy is responsible for calling the classifiers so it be responsible for deciding how to handle a classifier error. I don't foresee a use case where an error returned by a classifier would be interpreted either by classifiers following the failed classifier or the retry strategy.

## Changes checklist

- [ ] Add retry classifiers field and setters to `RuntimeComponents` and `RuntimeComponentsBuilder`.
  - [ ] Add unit tests ensuring that classifier priority is respected by `RuntimeComponents::retry_classifiers`, especially when multiple layers of config are in play.
- [ ] Add codegen customization allowing users to set retry classifiers on service configs.
- [ ] Add codegen for setting default classifiers at the service level.
  - [ ] Add integration tests for setting classifiers at the service level.
- [ ] Add codegen for settings default classifiers that require knowledge of operation error types at the operation level.
  - [ ] Add integration tests for setting classifiers at the operation level.
- [ ] Implement retry classifier priority.
  - [ ] Add unit tests for retry classifier priority.
- [ ] Update existing tests that would fail for lack of a retry classifier.

<!-- Links -->

[sort]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.sort
